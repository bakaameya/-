在执行时先执行父类
如果父类的成员变量私有化，则子类没法访问到父类的成员变量。
执行时如果寻找变量现在自身类中找，如果本类中有则在本类中取值，如果本类中没有则去父类中寻找成员变量。
使用super关键字可以直接访问父类中的成员变量而跳过从子类中寻找。
与this的区别：
This是当前类中的成员变量，范围是方法和类成员，而super中的范围是子类和父类。
////////////////////////////////////////////////////////////////////////////////////////////
如果子类中有和父类相同的方法则调用方法时只会调用子类中的方法而不会寻找到父类。
如果子类中和父类有同名的方法（且参数一样）则我们称之为方法的重写。子类的方法覆盖父类的方法。

当需要拓展父类的一些功能的时候，我们则需要重写父类方法来拓展。（当然父类中有的功能也会被相应的继承下来。）
重写方法名相同，参数列表相同。
子类中修饰符访问权限不能低于父类
父类中私有化的方法不能被重写
static方法不能被重写（因为静态方法只会在内存中加载一次）

继承的弊端：
破坏了封装性，即可以重写父类中的方法。
反之如果不让重写方法的话就没有继承可言。final关键字可以权衡这个问题
子类是不能继承final类的


多态：
当使用变量时，会直接使用父类的变量；
而当调用方法时，会先检查父类中有无声明调用的方法，编译通过之后会运行子类中方法的重写
如果调用的是静态方法则加载时会加载父类的方法。