集合和数组不一样，数组的长度是固定的，而且只能添加一种类型
但是集合可以添加多种类型，长度是动态的
collection是一个接口，不能直接实例化
初始化：collection 实体名 = null
所有添加进collection中的数据都会被转换成对象的形式（集合存储的是对象的串）
Collection 对象名 = new Arraylist<>();

//arraylist创建的是一个数组的结构，元素可以重复，是顺序的

来声明一个‘数组？’，ArrayList实现了父类collection，父类实例化了子类的对象，是多态的体现
collection中的方法：
add：向数组中添加元素
remove：删除元素
contains：判断元素是否存在，返回值为布尔类型
isEmpty：判断数组是否为空
size：返回数组的元素个数
clear：删除所有元素
addAll：将一个数组中的元素添加到另一个数组
containsAll：一个集合包含另一个集合中的所有元素

迭代器：    iterator 对象 = 对象.iterator（）：从集合中取元素
其中iterator对象所拥有的方法：
hasNext：判断是否有元素
next：取下一个



list：可以存重复元素
List 对象名 = new arrayList<>();
add(new 对象(**,**,**));可以实现直接添加对象
想要取到这里面的值方法和上述迭代器相同,不过这里因为保存的是对象所以会拿到对象的地址
再在后面使用toString方法可以将值输出出来
add如果跟两个参数则第一个是集合下标,第二个是相关元素,即在指定下标的位置插入元素
set方法：设置指定下标的元素值（修改）
list中的get方法可以获取list中的元素，可以像数组一样输出元素

Linklist：创建的是一个链表的结构
链表元素是有头和尾的（参考数据结构）
头指针保存着上个元素的物理地址，还要有一个指针保存着自己的地址
所以linklist用起来会比较慢（查找慢），因为需要按照指针一个个去寻找
方法：linkfirst、linklast，分别添加在开头和末尾（链表元素）
removefirst、last：删除首尾
////////////////////////////////////
以上两者线程不同步，在多线程中不安全


set接口：也是继承了collection类
但是set不包含重复元素
set的实现类：hashSet  创建一个hash表，迭代不一定是线性的
哈希冲突解决方法：先判断经过散列算法算出的地址值是否相同，如果相同的话再调用equals方法看看是否完全相同
如果相同储存，如果不同不存。相同是储存是在同一地址上创建指针指向一个新的地址
因为寻找元素是是按照哈希值来寻找再判断是否有地址指针所以查询速度比数组的顺序查找快很多
当然hash集合中也可以存储对象（引用类型）
存储对象是可以存相同值时因为每个对象的地址值都是不同的
如果像去重需要又见自己生成hashcode方法去判断。（默认继承object类中的hashcode方法）

treeset：存入其中的元素会按照自然顺序进行排序(int顺序是从小到大，字符类型按照字典顺序)
treeset是treemap的一个实现类
是二叉树结构储存，大于放入左节点，小于放入右节点，这样遍历的时候每次只比较两个值就知道下个值去哪边寻找
想要在treeset集合中添加对象元素需要继承compare接口，然后实现接口中的compareTo方法。
public int compareTo(Object o){
	int temp = Person p = (Person)o;
//此处要转化为person对象是因为在主方法中集合存储的对象都是person对象，
//而compareTo方法默认比较的是任意两个对象，所以要转化成具体对象
	int temp = this.age - p.age;//当然这里的temp等于什么值用来做下面的判断是你自己规定的
	return temp==0？this.name.compareTo(p.name):temp;//如果年龄相同则比较姓名
}



可以用foreach来遍历集合（同样foreach可以用来遍历数组吗，不过不能遍历这两个内容以外）
格式：for(Object 临时对象名 : 对象集合){
	//object是所有类型的父类，所以可以用来接收所有类型
}

泛型：集合类型关键字声明的时候后面<>中所存放的内容。
如果尖括号中存放的没有数据则默认可以储存任何数据（类型为object），如果规定存储数据的类型则
放入其他类型的数据的时候会报错。
iterator迭代器的后面也可以规定类型，从而取出的值为相应的数据类型。
但是尖括号中不能直接存放数值，只能存放一个对象的类型
规定集合中可以存放的数据类型有利于安全，也主要解决了强转的问题


泛型类对象类型：
直接在类名后面加<E>，然后成员变量的变量类型直接用E来代替
这样E相当于一个参数，当在其他地方需要调用该类时实例化对象要用泛型的方式标注对象类型。
public <name> void (name sonname){
	//一个带泛型的方法
}
如果不知道父类是什么类型的时候子类在实现的时候可以用泛型




map集合：[是一种映射关系]
存储的数据是一个键值对的类型（有点类似json的感觉）
相同键值存不同数据时会出现新值将原值替换掉
方法：
put：参数两个，第一个为键值，第二个为数据
打印结果为{key = value}
key不一定是数字，泛型时也可以为字符串或者其他数据
put方法返回值为key的旧值，如果是第一次使用则返回null
get：返回键值所对应的值
remove：删除对应键值的数据（貌似操作都是通过对键值来进行的，相当于主键？）
Set <> name = object.keySet();//返回set类型对应映射的键值
map集合中并不能直接取值
getKey、getValue：分别为获取键值和数据
map是集合中的一个接口，entry是它的一个类型
Set<Map.Entry<Integer,String>> name = map.entrySet();
Iterator<Entry<,>> name = name.iterator();
通过这种方式可以使用entrySet取到键值和元素的值
entry是一种类型（即可以存放一组映射的类型）